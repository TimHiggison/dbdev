{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>dbdev</code>","text":"<p>Documentation: https://supabase.github.io/dbdev</p> <p>Source Code: https://github.com/supabase/dbdev</p>"},{"location":"#overview","title":"Overview","text":"<p>dbdev is a package manager for Postgres trusted language extensions (TLEs). It consists of:</p> <ul> <li>database.dev: our first-party package registry to store and distribute TLEs.</li> <li>dbdev CLI: a CLI for publishing TLEs to a registry.</li> <li>dbdev client: an in-database client for installing TLEs from registries.</li> </ul> <p>If you want to publish your own TLE, you will need the dbdev CLI. Follow its installation instructions to get started.</p> <p>If you want to install an extension from the registry, you will need the SQL dbdev client. Follow its installation instructions to enable it in your database.</p> <p>Warning</p> <p>Restoring a logical backup of a database with a TLE installed can fail. For this reason, dbdev should only be used with databases with physical backups enabled.</p>"},{"location":"cli/","title":"Using the CLI","text":"<p>The <code>dbdev</code> CLI can be used for:</p> <ul> <li>Installing TLEs from [database.dev] or your local machine.</li> <li>Updating TLEs from [database.dev] or your local machine.</li> <li>Publishing TLEs to database.dev.</li> </ul>"},{"location":"cli/#installation","title":"Installation","text":"<p>Installation is available through a native package, binary download or building from source.</p>"},{"location":"cli/#native-package","title":"Native Package","text":"macOSLinuxWindows <p>Install the CLI with Homebrew: <pre><code>brew install supabase/tap/dbdev\n</code></pre></p> <p>Install the CLI with Homebrew: <pre><code>brew install supabase/tap/dbdev\n</code></pre></p> <p>Install the CLI with Scoop. <pre><code>scoop bucket add supabase https://github.com/supabase/scoop-bucket.git\nscoop install dbdev\n</code></pre></p>"},{"location":"cli/#linux-packages","title":"Linux packages","text":"<p>Debian Linux packages are provided in Releases. To install, download the <code>.deb</code> file and run the following:</p> <pre><code>sudo dpkg -i &lt;...&gt;.deb\n</code></pre>"},{"location":"cli/#upgrading","title":"Upgrading","text":"<p>Use <code>dbdev --version</code> to check if you are on the latest version of the CLI.</p>"},{"location":"cli/#native-package_1","title":"Native Package","text":"macOSLinuxWindows <p>Upgrade the CLI with Homebrew: <pre><code>brew upgrade dbdev\n</code></pre></p> <p>Install the CLI with Homebrew: <pre><code>brew upgrade dbdev\n</code></pre></p> <p>Update the CLI with Scoop. <pre><code>scoop update dbdev\n</code></pre></p>"},{"location":"cli/#linux-packages_1","title":"Linux packages","text":"<p>Debian Linux packages are provided in Releases. To upgrade, download the <code>.deb</code> file and run the following:</p> <pre><code>sudo dpkg -i &lt;...&gt;.deb\n</code></pre>"},{"location":"cli/#binary-download","title":"Binary Download","text":"<p>Binaries for dbdev CLI are available for Linux, Windows and macOS platforms. Visit the dbdev releases page to download a binary for your OS. The downloaded binary should be placed in a folder which is in your PATH.</p>"},{"location":"cli/#build-from-source","title":"Build From Source","text":"<p>Alternatively, you can build the binary from source. You will need to have Rust installed on your system. To build from source:</p> <ol> <li>Clone the repo: <code>git clone https://github.com/supabase/dbdev.git</code>.</li> <li>Change directory to <code>dbdev</code>: <code>cd dbdev</code>.</li> <li>Build: <code>cargo install --release</code>.</li> <li>Copy the <code>dbdev</code> binary in <code>target/release</code> to a folder in your PATH.</li> </ol> <p>If you have cargo-install, you can perform all the above steps with a single command: <code>cargo install --git https://github.com/supabase/dbdev.git dbdev</code>.</p> <p>Now you're ready to publish your first package.</p>"},{"location":"extension_structure/","title":"Structure of a Postgres Extension","text":"<p>A Postgres trusted language extension (TLE) consists of the following files:</p> <ol> <li>Script files. These files contain the SQL commands to create the extension's objects.</li> <li>Control files. These files contain basic properties of the extension itself.</li> </ol> <p>For an extension to be valid, one file of each type must be present in an extension. For example, if you want to create an extension named <code>my-extension</code>, create the following folder structure:</p> <ul> <li>my-extension<ul> <li>my-extension.control</li> <li>my-extension--0.0.1.sql</li> <li>README.md</li> </ul> </li> </ul> <p>In the above example, the <code>my-extension</code> folder contains the extension files. Names of the files are important. The control file should be named <code>&lt;extension_name&gt;.control</code> and the script file should be named <code>&lt;extension_name&gt;--&lt;extension_version&gt;.sql</code>. The readme file should be named <code>README.md</code> (case sensitive).</p>"},{"location":"extension_structure/#control-files","title":"Control Files","text":"<p>A control file contains metadata about the extension in key-value pairs. The most common keys that you should consider setting are the following:</p> <ul> <li>default_version (string). The version to use if the user doesn't provide one in the <code>create extension</code> command.</li> <li>comment (string). A comment added to the extension object created in the database.</li> <li>requires (string). A comma separated list of extensions that this extension depends on.</li> <li>relocatable (boolean). Set to true if the extension's objects can be moved to a different schema after they are created.</li> <li>superuser (boolean). Set to true if only superusers should be able to create this extension.</li> </ul> <p>For example, the pgjwt extension's control file looks like this:</p> <pre><code># pgjwt extension\ncomment = 'JSON Web Token API for Postgresql'\ndefault_version = '0.2.0'\nrelocatable = false\nrequires = pgcrypto\nsuperuser = false\n</code></pre> <p>For a complete list of keys available in a control file, refer to Postgres documentation.</p>"},{"location":"extension_structure/#syntax","title":"Syntax","text":"<p>A control file contains key-value pairs. Each pair should be on a separate line. Empty lines are ignored. Text after a <code>#</code> is a comment and is also ignored. Keys should start with a letter and contain only letters or digits. The <code>=</code> sign following a key is optional, but there must be at least one whitespace after a key if <code>=</code> is omitted. Values can be either a boolean or a string. Valid values for a boolean are <code>true</code> or <code>false</code>. Strings are anything between a pair of single quotes. If you want to include a single quote in the middle of a string, use <code>''</code> to escape it. A complete list of escape sequences is:</p> <ol> <li><code>\\b</code> - backspace</li> <li><code>f</code> - formfeed</li> <li><code>\\n</code> - newline</li> <li><code>\\r</code> - carriage return</li> <li><code>\\t</code> - tab</li> <li><code>''</code> - single quote</li> </ol> <p>Strings which do not contain whitespace or escape sequences can be written without the surrounding single quotes.</p> <p>Some examples of valid control file syntax follow:</p> <pre><code># A boolean value\nrelocatable = true\n\n# `=` is optional\nsuperuser false\n\n# A string\ncomment = 'a comment for the extension'\n\n# A string without quotes should not have whitespace or escape sequences\ncomment = ACommentForTheExtension\n\n# A string with escapse sequences\ncomment = 'A double quote '' and a newline \\n'\n</code></pre>"},{"location":"extension_structure/#script-files","title":"Script Files","text":"<p>Script files contain the SQL commands to create or modify database objects. These database objects can be, but are not limited to, tables, views, functions, types, operators etc. For example, the pgjwt's <code>pgjwt--0.1.1.sql</code> file contains definitions for functions which the extension adds to the database. One exception to the SQL commands which can exist in a script file are transaction control commands like <code>BEGIN</code>, <code>COMMIT</code>, <code>ROLLBACK</code> etc.</p> <p>You might have noticed a strange line at the beginning of the <code>pgjwt-0.1.1.sql</code> file starting with <code>\\echo</code>. This line prevents the script file from being run accidentally in <code>psql</code>. Lines starting with <code>\\echo</code> are run only in <code>psql</code> but are ignored when the script file is executed by the <code>CREATE EXTENSION</code> command. It is recommended that you include such a line at the beginning of your script file.</p>"},{"location":"extension_structure/#update-scripts","title":"Update Scripts","text":"<p>Update scripts are used to update an installed extension. An update script should be named <code>&lt;extension_name&gt;--&lt;old_version&gt;--&lt;new_version&gt;.sql</code>. For example if version <code>1.0</code> of <code>my-extension</code> was published already and you want to publish a new version <code>1.1</code> you need to create <code>my-extension--1.0--1.1.sql</code>. Update scripts can create new database object or modify/delete existing objects created by the previous version of the extension.</p>"},{"location":"extension_structure/#readmemd-file","title":"README.md File","text":"<p>README.md file contains documentation for the extension in the markdown format. The documentation typically contains installation and usage instructions about the extension.</p>"},{"location":"install-in-db-client/","title":"Install a Package","text":"<p>You can install extensions available on the database.dev registry using the dbdev in-database client. The dbdev client is itself an extension which you can install by following the instructions below.</p>"},{"location":"install-in-db-client/#installation","title":"Installation","text":"<p>Before you can install the dbdev extension into your database, ensure you have the following dependencies already installed:</p> <ul> <li>pg_tle</li> <li>pgsql-http</li> </ul> <p>Note</p> <p>If you database is running on Supabase, the above dependencies are already installed.</p> <p>Run the following SQL to install the client:</p> <pre><code>create extension if not exists http with schema extensions;\ncreate extension if not exists pg_tle;\n-- drop dbdev with older naming scheme if present\ndrop extension if exists \"supabase-dbdev\";\nselect pgtle.uninstall_extension_if_exists('supabase-dbdev');\ndrop extension if exists \"supabase@dbdev\";\nselect pgtle.uninstall_extension_if_exists('supabase@dbdev');\nselect\npgtle.install_extension(\n'supabase@dbdev',\nresp.contents -&gt;&gt; 'version',\n'PostgreSQL package manager',\nresp.contents -&gt;&gt; 'sql'\n)\nfrom http(\n(\n'GET',\n'https://api.database.dev/rest/v1/'\n|| 'package_versions?select=sql,version'\n|| '&amp;package_name=eq.supabase@dbdev'\n|| '&amp;order=version.desc'\n|| '&amp;limit=1',\narray[\n('apiKey', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhtdXB0cHBsZnZpaWZyYndtbXR2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE2ODAxMDczNzIsImV4cCI6MTk5NTY4MzM3Mn0.z2CN0mvO2No8wSi46Gw59DFGCTJrzM0AQKsu_5k134s')::http_header\n],\nnull,\nnull\n)\n) x,\nlateral (\nselect\n((row_to_json(x) -&gt; 'content') #&gt;&gt; '{}')::json -&gt; 0\n) resp(contents);\ncreate extension \"supabase@dbdev\";\nselect dbdev.install('supabase@dbdev');\ndrop extension if exists \"supabase@dbdev\";\ncreate extension \"supabase@dbdev\";\n</code></pre>"},{"location":"install-in-db-client/#use","title":"Use","text":"<p>Once the client is installed, you an install a TLE available on database.dev by running SQL that looks like the following:</p> <pre><code>select dbdev.install(&lt;extension_name&gt;);\ncreate extension &lt;extension_name&gt;\nschema &lt;schema&gt;\nversion &lt;version&gt;;\n</code></pre> <p>For example, to install pg_headerkit version 1.0.0 in schema public run:</p> <pre><code>select dbdev.install('burggraf@pg_headerkit');\ncreate extension \"burggraf@pg_headerkit\"\nschema 'public'\nversion '1.0.0';\n</code></pre>"},{"location":"publish-extension/","title":"Publish a Package","text":"<p>Let's create your first Trusted Language Extension for database.dev.</p>"},{"location":"publish-extension/#create-your-package","title":"Create your package","text":"<p>Create a folder which will contain the extension:</p> <pre><code>mkdir my_first_tle\ncd my_first_tle\n</code></pre> <p>Next create a <code>hello_world--0.0.1.sql</code> file, which will contain your extension's SQL objects. Add the following function definition to this file:</p> <pre><code>create function greet(name text default 'world')\nreturns text\nlanguage sql\nas $$\nselect 'hello, ' || name;\n$$;\n</code></pre> <p>Let's also add some docs about this extension. Create a <code>README.md</code> file and add the following content to it:</p> <pre><code>The `hello_world` extension provides a `greet` function, which returns a greeting.\n</code></pre> <p>Lastly, add a <code>hello_world.control</code> file with the following key-value pairs:</p> <pre><code>default_version = 0.0.1\ncomment = 'An extension to generate greetings'\nrelocatable = true\n</code></pre> <p>Your extension is ready to publish. Its name is <code>hello_world</code> and version is <code>0.0.1</code>. For details about what constitutes a valid extension, read about the Structure of an Extension.</p>"},{"location":"publish-extension/#login-to-databasedev","title":"Login to database.dev","text":"<p>Before you can publish your extension, you need to authenticate with database.dev. If you don't have an account, sign-up for one on the website. Then follow the steps below:</p> <ol> <li>Make sure you are logged into the <code>database.dev</code> website.</li> <li>Navigate to the Access Tokens page from the account drop-down at top right.</li> <li>Click New Token.</li> <li>Enter a token name and click Create Token.</li> <li>Copy the generated token. Note that this is the only time the token will be shown.</li> <li>On the terminal, run the <code>dbdev login</code> command.</li> <li>Paste the token you copied.</li> </ol>"},{"location":"publish-extension/#publish-your-extension","title":"Publish your extension","text":"<p>Now run the <code>dbdev publish</code> command to publish it.</p> <pre><code>dbdev publish\n</code></pre> <p>Your extension is now published to <code>database.dev</code> and visible under your account profile. You can visit your account profile from the account drop-down at the top right. Users can now install your extension using the dbdev in-database client.</p>"},{"location":"publish-extension/#tips","title":"Tips","text":"<p>Here are a few useful tips for creating extensions.</p>"},{"location":"publish-extension/#dont-hardcode-schemas","title":"Don't hardcode schemas","text":"<p>It's common to hardcode <code>public</code> into your SQL files, but this isn't a great practice. Remove all hard-coded schema references so that the user can choose to install the extension in other schemas.</p>"},{"location":"publish-extension/#relocatable-schemas","title":"Relocatable schemas","text":"<p>You can define a schema to be <code>relocatable</code> in the <code>.control</code> file:</p> <pre><code>default_version = 0.0.1\ncomment = 'An basic extension.'\nrelocatable = true\n</code></pre> <p>If this is <code>true</code>, users can choose where to install their schema:</p> <pre><code>create extension &lt;extension_name&gt;\nschema &lt;schema&gt;\nversion &lt;version&gt;;\n</code></pre> <p>If you need to reference the schema in your SQL files, you can use the <code>@extschema@</code> parameter:</p> <pre><code>create function @extschema@.my_function(args)\nreturns return_type\nlanguage plpgsql\nas $$\nbegin\n-- function body\nend;\n$$;\n</code></pre>"}]}